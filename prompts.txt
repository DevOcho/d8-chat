Current prompt:

You've been assiting me in building a slack clone application and I'd like to continue adding features and fixing bugs in it.  We are using Python Flask, Python Peewee, HTMX, Bootstrap, the htmx websockets extension, etc.  You can use the code I will provide to gain additional context on the technology.  For example, the requirements.txt file to see the python modules installed.
I'd like you to follow a few rules when helping me code:
    * I prefer short code snippets with explanations of where they go (line number suggestions when possible).  I also understand that occasionally it's easier to give me entire sections or files.  If you do that please give me the entire code and not most of it with commented out sections.  I can make copy paste errors if I don't realize you only want me to make small changes but give me large sections of code.  Best option is to give me the code change and the code before or after where you want me to make it.
    * If we are fixing a bug, ask me if the fix worked. Don't tell me it worked, and don't ask me to move on to the next thing until I confirm it's actually fixed.
    * Don't remove existing comments from the code when you ask me to replace large sections.  Those comments are helpful.  When you replace a large section, please leave the comments in place or update them to reflect new behavior.  My personal rule is that I comment if I press enter twice.
    * Never minify CSS or JavaScript.  I can't read it if you minify it.  Follow the popular linter's style here.

Here is the code for context as well as a `tree` command to show you what I left out:

Context:

find . -type f \( -name "*.html" -o -name "*.ini" -o -name "*.py" -o -name "*.css" -o -name "*.js" -o -name "*.txt" \) -not -path "*/local/*" -not -path "*/lib/*" -not -path "*/bin/*" -not -name "prompts.txt" -not -name "issues.txt" -exec sh -c 'echo "File: {}"; cat {}; echo' \;

tree -I 'bin|lib|.git|__pycache__|*.pyc'

pytest --cov=app --cov-report=term-missing

Search prompt:

You are an expert software engineer specializing in building chat applications like Slack clones. The user is developing a Slack-like application and wants to add a comprehensive "search" feature that mimics how Slack handles searching. Based on Slack's official behavior:Searchable Content: Messages (including threads and direct messages), files, channels, people (users/coworkers), canvases (if your app supports document-like features; otherwise adapt to similar entities), and workflows (mobile-only filters). Archived channels and their messages/files remain fully searchable (on paid plans in Slack; assume always searchable in your app unless you implement plan tiers). Deleted content is not searchable.
Accessing Search: Via a search bar at the top of the app (desktop/mobile). Keyboard shortcuts: Cmd/Ctrl + G for global search, Cmd/Ctrl + F for in-conversation search. Recent searches are suggested in the dropdown.
Basic Search: Simple keyword entry. Use quotes for exact phrases (e.g., "marketing report"). Dash to exclude words (e.g., marketing -report). Asterisk for partial matches (min 3 chars, e.g., rep* for "report" or "reply").
Advanced Operators/Modifiers: in:channel-name (search in specific channel, DM, or section).
from:@user
 (content from a specific user).
has::emoji: (messages with specific reactions; hasmy::emoji: for user's own reactions).
has:link or has:pin (messages with links or pins).
is:saved (saved items), is:thread (within threads).
with:@user
 (threads/DMs with a person).
creator:@user
 (for canvases or similar).
Date filters: before:YYYY-MM-DD, after:YYYY-MM-DD, on:YYYY-MM-DD, during:month/year.
Combine operators (e.g., "report" in:#marketing from:@user
 after:2025-01-01).
Operators are case-insensitive; support AND/OR implicitly (spaces = AND).

Filters and Refinements: After searching, allow filtering by type (Messages, Files, People, Channels, Canvases). On mobile, include Workflows. Provide a "Filters" button for further refinement (e.g., date ranges, people, channels). Support sorting (e.g., relevance, date).
Search Results Display: Show snippets with highlighted keywords. Group by type (tabs or sections for Messages, Files, etc.). Include context (e.g., channel name, sender, date). Paginate results. For channels/people, show previews. Integrate natural language AI if possible (optional enhancement).
Behavior for Archived Content: Messages/files in archived channels remain searchable via global search. Results link to the archived channel (read-only). When browsing channels, include a filter for "Archived channels" to find them.
Permissions and Limitations: Available to all users (including guests, but perhaps limited). On Slack's free plan, archived search is restrictedâ€”implement optional plan-based checks if your app has tiers. Admins can customize search preferences (e.g., default modifiers).
Edge Cases: Handle no results gracefully. Search history: Store and suggest recent searches. Deleted items: Exclude from results. Performance: Use indexing for large datasets. Mobile vs. Desktop: Slightly different filters (e.g., workflows on mobile).
Integrations: If your app has canvases/clips, make them searchable. Optional AI for natural language queries.

archive prompt:

You are an expert software engineer specializing in building chat applications like Slack clones. The user is developing a Slack-like application and wants to add an "archive channel" feature that mimics how Slack handles channel archiving. Based on Slack's official behavior:What happens when a channel is archived: The channel becomes read-only. No new messages, files, or activities can be added. Existing message history is retained and remains searchable. Workflows or integrations (if any) are paused or unpublished. Certain default channels (e.g., equivalent to Slack's #general) cannot be archived.
Visibility: Archived channels do not appear in the main active channel list or join options. They are hidden from default views but can be found via a dedicated "Archived channels" section or filter in the channel browser.
Accessibility: Users can still visit the archived channel to view and read historical messages. They can navigate to it via search or the archived list.
User interactions: Users cannot post new messages, upload files, or perform other write actions. Read actions (e.g., viewing messages, searching within the channel) are allowed. Archiving is reversible via unarchiving.
Searchability: Archived channels and their messages remain fully searchable in the app's global search. They appear in search results, allowing users to access them.
Unarchiving: Channels can be unarchived, restoring them to active status. For public channels, former members are not automatically rejoined (users must rejoin manually). For private channels, original members are retained. The channel name cannot be reused for a new channel while archived.
Permissions and roles: By default, channel members (except restricted users like guests) can archive channels they're part of. Workspace owners/admins can restrict this permission. Only owners/admins should have the ability to delete channels (as a related but separate feature). Channel managers (if your app has this role) can always archive their assigned channels.
Notifications: No new notifications are sent for archived channels since no new activity occurs. Existing notifications (e.g., for old mentions) may still be accessible in user history.
Differences for roles: Regular members can archive/unarchive channels they're in (unless restricted). Owners/admins have override permissions and can manage from a central dashboard if implemented. On free/limited plans (if your app has tiers), searchability of archived history might be restricted, but assume full access for now.
Related features: Implement archiving as reversible; deletion should be a separate permanent action that removes the channel and history entirely. Ensure retention policies (if any) don't apply to deleted channels.




initial prompt:

I want to create an AI prompt that will help me work with AI to code a slack clone.  I don't want video chats or phone calls.  Just regular chat stuff.  Direct messages, public and private channels with moderators, etc.  I want image support and emojies in the chat.  I'd like the same styles for the chat bar (press up to edit, /commands, etc.).  I'd also like a full administration panel that allows me to create users and set permissions on the users.  I don't want a link to invite users or self-signup.  This will be used by businesses so users never need to just show up.

System Features:
- SSO capabilities that would be compatible with Authentik and Google Workspace.  This will include groups/permissions and if the user exists in the SSO system it should be created in the chat.
- Capabilities to support 20 to ~10,000 users
- I'm probably missing things here that you could help me add.

Technology:
- I'd like to use Python, HTMX, Bootstrap (or another CSS framework if that would make it easier).
- MySQL or Postgres for the database and I want to connect with Python Peewee and the associated tools (Playhouse, etc)
- Image and file hosting via Minio
- I'm ok with a microservices architecture pattern but I'd prefer a monolith to start
- I want to host in both Docker Compose and Kubernetes setups.

What else do you think I need to include for this prompt?

-----------------------------------------------------------------------------------------------------------------

AI Master Prompt: Collaborative Development of a Corporate Chat Application ("Py-Slack")
Your Role: You are an expert software architect and senior full-stack Python developer. Your expertise covers real-time web applications, database design, secure authentication systems, and modern deployment practices. You will act as my collaborative partner in building a new chat application.
Our Goal: We will work together to design and build a secure, scalable, and self-hosted chat application, similar to Slack, designed for business use. We will build this application iteratively, focusing on a solid foundation and adding features in logical phases.

Mode of Interaction:
Be my Socratic Partner: Don't just give me code. Ask clarifying questions to ensure we're building the right thing. Explain the "why" behind your architectural and code suggestions.
Iterative Development: We will build this feature by feature. Provide code snippets for specific parts (e.g., a single Python function, an HTMX template snippet, a Peewee model) rather than entire files at once.
Maintain Context: Remember our technology stack and architectural decisions throughout our conversation.
Structure Your Responses: Use clear headings, code blocks with language identifiers (e.g., ```python), and bullet points to make your responses easy to follow.
Project Specification: Py-Slack

## Phase 1: Core Monolithic Application (MVP)
1. Core User-Facing Features:
Authentication: Users log in via an SSO provider. No self-signup or email/password.
Channels:
Public channels anyone in the workspace can join.
Private channels accessible by invitation only.
Direct Messages (DMs): 1-to-1 private conversations between users.
Messaging:
Send and receive text messages in channels and DMs.
Support for standard emojis.
Support for image and basic file uploads (e.g., PDFs, TXT files).
Basic Markdown support for message formatting (bold, italics, code blocks, blockquotes).
Chat UI/UX:
A classic three-pane layout: (1) Channels/DMs list, (2) Message history, (3) Message input box.
The message input bar should support Slack-like features: pressing the "Up Arrow" on an empty input box allows editing your last message.
[Suggested Addition] Real-time Updates: New messages should appear instantly for all users in a channel/DM without a page refresh. We will need a WebSocket implementation for this.
[Suggested Addition] Unread Indicators: Channels and DMs with new messages should be clearly marked (e.g., bolded with a badge count).
2. Administrative Features:
Full Admin Panel: A secure, separate section of the application.
User Management: Admins can create, view, edit, and deactivate users manually.
Channel Management: Admins can create/archive channels and assign channel moderators.
Permissions: Admins can assign roles to users (e.g., Admin, Member).
3. Technology Stack:
Backend: Python (using a web framework like FastAPI or Flask, you recommend which is better for this HTMX/WebSocket combo).
Frontend: HTMX for server-rendered HTML interactions.
CSS Framework: Bootstrap 5 (or you can propose a better alternative like Tailwind CSS if there's a strong reason).
Database: PostgreSQL (preferred) or MySQL.
ORM: Peewee, including peewee-db-evolve for migrations.
File Storage: Minio for S3-compatible object storage.
Architecture: A well-structured monolith to start.

## Phase 2: Enhancing User Experience & Moderation
[Suggested Addition] User Presence: Show user status (online/offline).
[Suggested Addition] Typing Indicators: Show when a user is typing a message in a DM or channel.
[Suggested Addition] Message Threads: Allow users to reply to a specific message, creating a threaded conversation.
[Suggested Addition] @Mentions: Allow users to type @username to notify another user directly.
[Suggested Addition] Search: Implement a basic search functionality to find messages.
[Suggested Addition] / Commands: Implement the basic framework for slash commands, starting with /shrug or /me.
[Suggested Addition] Moderator Abilities: Channel moderators (not just global admins) can remove users from their channels or delete messages within their channels.

## Phase 3: Scaling, SSO, and Deployment
System Scalability: Ensure the application is architected to support from 20 to ~10,000 concurrent users. This includes efficient database queries, connection pooling, and a performant WebSocket server.
SSO Integration:
Implement SSO login flows compatible with standard OIDC/SAML protocols.
Target compatibility with Authentik and Google Workspace.
Just-in-Time (JIT) Provisioning: If a user authenticates via SSO and does not exist in our database, create a user account for them automatically.
Group/Permission Mapping: Pull user groups from the SSO provider and map them to internal application roles (Admin, Member).
Deployment:
Provide a complete docker-compose.yml file for easy local development and small-scale production deployment.
Provide Kubernetes manifest files (Deployment, Service, Ingress, ConfigMap, Secret) for scalable production deployment.

-----------------------------------------------------

I want you to take the following software specification and break it down into a series of small promtps that I can use to get an advanced LLM to build software with me.  I'm looking for 20 to 25 individual prompts that make the software easy to update.  Each prompt adding a feature to the software.

{ include the above prompt }

-----------------------------------------------------

### Introduction for the User
Before you start, use this first message to set the context with your LLM partner for the entire project:

> **Initial Context-Setting Prompt:**
> "Hello! We're going to build a corporate chat application called 'Py-Slack' together. I have a detailed specification that we'll follow. Your role is to be my expert software architect and senior full-stack Python developer. Please act as a Socratic partner: ask clarifying questions, explain the 'why' behind your suggestions, and provide code in small, iterative snippets. We will build this feature by feature. Let's start with the first step: setting up the project foundation."

---

### Phase 1: Core Monolithic Application (MVP)

**Prompt 1: Project Setup and Technology Stack Decisions**
"Let's begin. First, help me decide on the core web framework. The spec mentions FastAPI or Flask. Given our goal of using HTMX and WebSockets, which would you recommend and why? Once we decide, please outline the initial project directory structure and the `requirements.txt` or `pyproject.toml` file with the essential dependencies (the chosen framework, Peewee, peewee-db-evolve, and a WebSocket library)."
*   **Tip for you:** This establishes the foundational choices and project layout.

**Prompt 2: Database and ORM Configuration**
"Great. Now, let's connect our application to a PostgreSQL database. Please provide the configuration code to connect our application to Postgres using Peewee. Also, show me how to set up `peewee-db-evolve` so we can manage database migrations. We will use environment variables for the database credentials."
*   **Tip for you:** This step isolates the database connection logic, a critical piece of infrastructure.

**Prompt 3: Core Database Models**
"With the database connected, let's define our core data structures. Please provide the Peewee models for `User`, `Channel`, and `Message`. Ensure you define the relationships correctly (e.g., a Message has a foreign key to a User and a Channel)."
*   **Tip for you:** This defines the "single source of truth" for your application's data.

**Prompt 4: Basic Application Server and Admin Panel Shell**
"Let's get something running. Please provide the minimal code to run a web server that responds with 'Hello, World!' on the root URL. Also, create a separate 'admin' section (using a Flask Blueprint or FastAPI APIRouter) that is accessible under `/admin`."
*   **Tip for you:** This verifies the web server works and organizes the admin functionality separately from the start.

**Prompt 5: Admin User Management (Create & View)**
"Let's build the first admin feature: user management. Inside the `/admin` section, create a simple HTML page with a form to manually create a new `User` (we only need a username and role for now). Below the form, display a table of all existing users."
*   **Tip for you:** This is your first end-to-end feature: a form, a handler, database interaction, and displaying results.

**Prompt 6: Core Chat UI Layout**
"Now for the main application. Let's create the classic three-pane chat UI using Bootstrap 5 and HTMX placeholders. Provide the base HTML template that defines the layout: a left sidebar for channels/DMs, a central pane for message history, and a bottom bar with a message input form. It doesn't need to be functional yet, just the static structure."
*   **Tip for you:** This focuses purely on the frontend structure without any backend logic.

**Prompt 7: Displaying Channels and DMs**
"Let's populate the left sidebar. Create a route that fetches all public `Channel`s from the database and renders them as a list of links in the sidebar. We'll use HTMX to load this content into the sidebar pane."
*   **Tip for you:** This introduces the first dynamic, data-driven UI component.

**Prompt 8: Viewing Channel Messages**
"When a user clicks a channel link in the sidebar, we need to show its messages. Using HTMX, make each channel link trigger a request to a new endpoint (e.g., `/channels/{channel_id}/messages`). This endpoint should fetch all messages for that channel and render them in the central message pane."
*   **Tip for you:** This implements the core functionality of switching between conversations.

**Prompt 9: Sending Messages (via HTMX)**
"Let's make the message input form functional. The form should `POST` to an endpoint that creates a new `Message` record in the database. After a successful post, use an HTMX response to append the new message to the bottom of the current message list without a full page refresh."
*   **Tip for you:** This completes the basic, non-real-time chat loop.

**Prompt 10: Integrating WebSockets for Real-Time Messages**
"Posting messages with HTMX is good, but it's not real-time for other users. Let's add WebSockets. Please guide me through setting up a WebSocket endpoint for a specific channel. When a message is sent, the server should broadcast it over the WebSocket to all connected clients in that channel, who will then append it to their UI."
*   **Tip for you:** This is a major step. Focus on getting one-way server-to-client communication working first.

**Prompt 11: Unread Message Indicators**
"Users need to know when there are new messages. Let's implement unread indicators. How can we track if a channel has messages a user hasn't seen? Propose a simple mechanism (e.g., using a 'last read' timestamp) and show me how to modify the channel list to display a badge or bold the text for unread channels."
*   **Tip for you:** This adds a crucial piece of UX that depends on both backend logic and frontend updates.

**Prompt 12: File Uploads with Minio**
"Let's add support for file uploads. Show me how to configure the application to connect to a Minio S3-compatible storage. Then, modify the message sending endpoint to handle a file upload, save it to Minio, and store the public-facing URL in the `Message` model."
*   **Tip for you:** This integrates a third-party service and handles multipart form data.

**Prompt 13: Basic Markdown Support**
"Let's format messages. When rendering messages, let's add support for basic Markdown. Please integrate a Python Markdown library to process the message text before it's rendered as HTML, converting things like `*italic*`, `**bold**`, and ```code blocks```."
*   **Tip for you:** This is a backend-focused display logic change.

**Prompt 14: 'Edit Last Message' UI Feature**
"Time for a nice UX touch. Let's implement the 'Up Arrow to Edit Last Message' feature. Please provide the necessary client-side JavaScript to detect this keypress on an empty input box. This should trigger an HTMX request to fetch the user's last message and place it in an 'edit' state."
*   **Tip for you:** This is a client-side heavy feature that will require a corresponding backend endpoint to handle the message update.

**Prompt 15: Admin Channel Management**
"Let's return to the admin panel. Add functionality for an admin to create new public/private channels and to archive existing ones. This will involve a new form and handler in our `/admin` section."
*   **Tip for you:** This builds out the administrative capabilities specified in the MVP.

### Phase 2: Enhancing User Experience & Moderation

**Prompt 16: User Presence (Online/Offline)**
"Let's show who is online. Using our WebSocket connection, how can we track and broadcast user presence? Show me how to update the user's status to 'online' on connect and 'offline' on disconnect, and how to display this status next to their name in the UI."
*   **Tip for you:** This leverages the existing WebSocket infrastructure for a new real-time feature.

**Prompt 17: Typing Indicators**
"Let's add typing indicators. This will also use WebSockets. Guide me through sending a 'start_typing' event from the client when a user starts typing in the input box, and a 'stop_typing' event after a short delay. The server should broadcast this to other users in the channel."
*   **Tip for you:** This enhances the real-time feel of the conversation.

**Prompt 18: Message Threads**
"Replying in a thread is a key feature. First, let's update our `Message` model to support threading (e.g., a `parent_message` self-referencing foreign key). Then, update the UI to include a 'Reply' button on each message, which will correctly associate the new message as a reply."
*   **Tip for you:** This involves both a database migration and significant UI changes.

**Prompt 19: @Mentions and Notifications**
"Let's implement @mentions. When a user types `@username`, we need to parse it on the backend when the message is saved. If a valid user is mentioned, how should we create a notification for them? Let's design a simple `Notification` model and the logic to create one."
*   **Tip for you:** This involves text processing, database lookups, and creating a new notification system.

**Prompt 20: Basic Message Search**
"Users need to find old messages. Let's add a basic search feature. Create a search bar and a new endpoint that takes a search query. This endpoint should perform a simple text search (e.g., using `ILIKE` in PostgreSQL) on the `Message` table and display the results."
*   **Tip for you:** This focuses on creating a new, read-only feature.

### Phase 3: Scaling, SSO, and Deployment

**Prompt 21: Initial SSO Integration (OIDC)**
"This is a big one. Let's replace our manual user creation with a proper SSO login. We'll target an OIDC provider like Google or Authentik. Please guide me in integrating a library like `Authlib` to handle the OIDC flow, including the callback endpoint and session management."
*   **Tip for you:** Start with just the login/logout flow. JIT provisioning can be next.

**Prompt 22: Just-in-Time (JIT) User Provisioning**
"Building on the SSO login, let's add JIT provisioning. When a user successfully authenticates via SSO for the first time, check if they exist in our `User` database. If not, create a new user account for them automatically using the information from the SSO provider (like email and name)."
*   **Tip for you:** This automates user creation and is a critical part of the SSO spec.

**Prompt 23: Dockerization for Development**
"To make development easier, let's containerize the entire application. Please provide a `Dockerfile` for our Python application and a `docker-compose.yml` file that orchestrates the app, the PostgreSQL database, and the Minio service."
*   **Tip for you:** This is a crucial step for reproducibility and preparing for production.

**Prompt 24: Kubernetes Deployment Manifests**
"For our final step, let's prepare for a scalable production deployment. Please provide a set of basic Kubernetes manifest files: a `Deployment` for the app, a `Service` to expose it, a `ConfigMap` for configuration, and a `Secret` for credentials. Explain the purpose of each file."
*   **Tip for you:** This is the capstone prompt, taking your application from a local setup to a cloud-native deployment plan.


-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------

### **AI Prompt for Building a Slack Clone**

---

### **Prompt 10: File Uploads with Minio**

**Your Prompt to the AI:**
"Integrate file and image uploading using Minio as the S3-compatible storage backend.

1.  **Add to `requirements.txt`**: Add `minio`.
2.  **Update `config.py`**: Add Minio configuration: `MINIO_ENDPOINT`, `MINIO_ACCESS_KEY`, `MINIO_SECRET_KEY`, and `MINIO_BUCKET`.
3.  **Create `app/files.py`**:
    *   Initialize the Minio client.
    *   Create a helper function that takes a file, generates a unique name, and uploads it to the Minio bucket.
4.  **Update `app/routes.py`**:
    *   Create a new route `POST /upload` that requires authentication.
    *   This route will handle the file upload from a form, use the helper function to save it to Minio, and then create a `File` record in the database.
5.  **Update `chat.html`**:
    *   Add a file input button next to the message input.
    *   When a file is sent, the message content posted to the backend should include the URL of the uploaded file.
    *   Update the message display logic to render an `<img>` tag for images or a link for other file types."

---

### **Prompt 11: Containerize for Development with Docker Compose**

**Your Prompt to the AI:**
"Create a local development environment using Docker and Docker Compose. This will orchestrate the Flask application, PostgreSQL database, and Minio service.

1.  **Create `Dockerfile`**: In the root directory, create a `Dockerfile` for the Flask application. It should:
    *   Start from a Python base image (e.g., `python:3.13-slim`).
    *   Set the working directory.
    *   Copy `requirements.txt` and install the dependencies.
    *   Copy the rest of the application code.
    *   Expose the application port (e.g., 5000).
    *   Specify the `CMD` to run the application using `gunicorn`.
2.  **Create `docker-compose.yml`**: In the root directory, create this file to define the services:
    *   **`app` service**: Builds from the `Dockerfile`. Mounts the local code as a volume for live reloading. Passes environment variables from the `.env` file. Depends on the `db` and `minio` services.
    *   **`db` service**: Uses the official `postgres:15` image. Sets up a persistent volume for data. Defines the `POSTGRES_USER`, `POSTGRES_PASSWORD`, and `POSTGRES_DB` environment variables.
    *   **`minio` service**: Uses the `minio/minio` image. Sets the root user and password. Exposes the API and console ports.

Provide instructions on how to run `docker-compose up` to start the environment and how to run the `init_db.py` and `seed.py` scripts inside the running `app` container."

---

### **Prompt 12: Convert to a Progressive Web App (PWA)**

**Your Prompt to the AI:**
"Now, let's enhance the user experience by converting the Flask application into a Progressive Web App (PWA). This will allow users to 'install' the app on their mobile devices and desktops, providing an app-like feel with offline capabilities.

1.  **Create the Web App Manifest**:
    *   In the `app/static/` directory, create a file named `manifest.json`.
    *   Populate this file with the necessary PWA metadata. This tells the browser how to behave when the app is installed.

    ```json
    {
      "name": "Enterprise Chat",
      "short_name": "Chat",
      "start_url": "/chat",
      "display": "standalone",
      "background_color": "#ffffff",
      "theme_color": "#4a154b",
      "description": "A real-time chat application for internal business use.",
      "icons": [
        {
          "src": "/static/icons/icon-192x192.png",
          "sizes": "192x192",
          "type": "image/png"
        },
        {
          "src": "/static/icons/icon-512x512.png",
          "sizes": "512x512",
          "type": "image/png"
        }
      ]
    }
    ```

2.  **Set Up Icon Directory**:
    *   Create a new directory: `app/static/icons/`.
    *   Note for the user: You will need to create two PNG icons, `icon-192x192.png` and `icon-512x512.png`, and place them in this directory.

3.  **Create the Service Worker**:
    *   In the `app/static/` directory, create a file named `service-worker.js`.
    *   This script will run in the background to cache the core application assets, enabling offline access. Add the following code for a "cache-first" strategy:

    ```javascript
    const CACHE_NAME = 'slack-clone-v1';
    const URLS_TO_CACHE = [
      '/',
      '/chat',
      '/static/manifest.json',
      // Add paths to your CSS and JS files here
      // e.g., '/static/css/bootstrap.min.css',
      // e.g., '/static/js/htmx.min.js',
      '/static/icons/icon-192x192.png',
      '/static/icons/icon-512x512.png'
    ];

    // Install event: cache the application shell
    self.addEventListener('install', event => {
      event.waitUntil(
        caches.open(CACHE_NAME)
          .then(cache => {
            console.log('Opened cache');
            return cache.addAll(URLS_TO_CACHE);
          })
      );
    });

    // Fetch event: serve from cache first, then network
    self.addEventListener('fetch', event => {
      event.respondWith(
        caches.match(event.request)
          .then(response => {
            // Cache hit - return response
            if (response) {
              return response;
            }
            return fetch(event.request);
          }
        )
      );
    });
    ```

4.  **Integrate PWA into the Main Template**:
    *   Modify `app/templates/base.html` to link the manifest and register the service worker.
    *   In the `<head>` section, add the following lines:

    ```html
    <!-- Link to the Web App Manifest -->
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">

    <!-- Theme color for the browser address bar on mobile -->
    <meta name="theme-color" content="#4a154b">
    ```
    *   At the very end of the `<body>` section, add the JavaScript block to register the service worker:

    ```html
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register("{{ url_for('static', filename='service-worker.js') }}")
            .then(registration => {
              console.log('ServiceWorker registration successful with scope: ', registration.scope);
            })
            .catch(err => {
              console.log('ServiceWorker registration failed: ', err);
            });
        });
      }
    </script>
    ```

---

### **Prompt 13: Generate a Comprehensive README File**

**Your Prompt to the AI:**
"Please generate a comprehensive `README.md` file for our 'Enterprise-Grade Monolithic Slack Clone' project. The file should be well-structured, easy to read, and contain all the necessary information for a new developer to understand, set up, and contribute to the project.

The README should include the following sections, formatted with Markdown:

1.  **Project Title**: Use `Enterprise-Grade Monolithic Slack Clone`.
2.  **Introduction**: A brief paragraph describing the project. Mention that it's a real-time chat application built with Python (Flask) and HTMX, designed for internal business use.
3.  **Core Features**: Create a bulleted list detailing the main functionalities. This list should be based on the original project description and include:
    *   User Authentication & Authorization (SSO with no self-signup)
    *   Real-time Chat (Public/Private Channels, DMs, Typing Indicators, Read Receipts)
    *   Advanced Message Features (File/Image support, Emoji reactions, Edit last message)
    *   Administration Panel (User, Permission, and Workspace Management)
    *   Notifications, Search, User Presence, Threads, and User Profiles.
4.  **Technology Stack**: A section listing the key technologies used. Create a table with two columns: 'Component' and 'Technology'. Include entries for Backend, Frontend, Database, Real-time, File Storage, and Deployment.
5.  **Local Development Setup**: This is a critical section. Provide clear, step-by-step instructions for setting up the local development environment using Docker Compose.
    *   Mention the prerequisites: `Docker` and `Docker Compose`.
    *   Step 1: Clone the repository.
    *   Step 2: Create and configure the `.env` file. Provide a template by copying the contents of `.env.example` and explain that the user needs to fill in the values.
    *   Step 3: Build and run the services using the `docker-compose up --build` command. Explain what this command does.
    *   Step 4: Initialize the database by showing the command to run the `init_db.py` script inside the running container: `docker-compose exec app python init_db.py`.
    *   Step 5: (Optional) Seed the database with test data using the command: `docker-compose exec app python seed.py`.
    *   Step 6: Access the application by directing the user to `http://localhost:5000`.
6.  **SSO Configuration Guide**: This is another critical section. Explain how to set up the SSO integration with Authentik and Google Workspace.
    *   Explain that the SSO provider details must be added to the `.env` file.
    *   **For Authentik**:
        *   Provide a brief guide on where to find the `OIDC_ISSUER_URL`, `OIDC_CLIENT_ID`, and `OIDC_CLIENT_SECRET` within the Authentik Admin interface (e.g., "In Authentik, navigate to Applications -> Providers, select your OAuth2/OpenID Provider, and find the Client ID/Secret. The Issuer URL is your Authentik domain.").
        *   Mention that the redirect URI to be configured in Authentik should be `http://localhost:5000/auth`.
    *   **For Google Workspace**:
        *   Provide a similar guide for Google Cloud Platform. (e.g., "In the Google Cloud Console, navigate to 'APIs & Services' -> 'Credentials'. Create an 'OAuth 2.0 Client ID' for a 'Web application'. The Client ID and Secret will be provided there.").
        *   Specify the 'Authorized redirect URIs' to be added in the Google Cloud credential settings: `http://localhost:5000/auth`.
7.  **Project Structure**: Briefly explain the purpose of the main directories and files, such as `app/`, `run.py`, `config.py`, `Dockerfile`, and `docker-compose.yml`. This helps new developers navigate the codebase.
8.  **Contributing**: Add a small section encouraging contributions and outlining the basic workflow (e.g., "Fork the repo, create a new branch, make your changes, and open a pull request.").

Please ensure the final output is a single, well-formatted Markdown file."
